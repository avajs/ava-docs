___
**Note du traducteur**

C'est la traduction du fichier [03-assertions.md](https://github.com/avajs/ava/blob/main/docs/03-assertions.md). Voici un [lien](https://github.com/avajs/ava/compare/b208d143ad852dc95aa8b44eed94ac1f404a25f4...main#diff-491b7f8141be104f0e85aed88fc1e100b192c25883c5f293457e5f85a299020c) vers les diffÃ©rences avec le master de AVA (Si en cliquant sur le lien, vous ne trouvez pas le fichier `03-assertions.md` parmi les fichiers modifiÃ©s, vous pouvez donc en dÃ©duire que la traduction est Ã  jour).
___
# Assertions

Traductions : [English](https://github.com/avajs/ava/raw/main/docs/03-assertions.md)

Les assertions sont incluses dans l'[objet d'exÃ©cution](./02-execution-context.md) fourni Ã  chaque implÃ©mentation de test :

```js
test('les licornes sont truthy (vraies)', t => {
	t.truthy('licornes'); // Assertion
});
```

Les assertions sont liÃ©es Ã  leur test de sorte que vous puissiez les affecter Ã  une variable ou les transmettre :

```js
test('les licornes sont truthy (vraies)', t => {
	const truthy = t.truthy;
	truthy('licornes');
});
```

Si plusieurs Ã©checs dâ€™assertion sont rencontrÃ©s au cours dâ€™un mÃªme test, AVA nâ€™affiche que le *premier*.

Les assertions retournent un boolÃ©en indiquant si elles ont rÃ©ussi. Vous pouvez utiliser ceci pour revenir plus tÃ´t d'un test. Notez que cela ne s'applique pas aux assertions "throws" et `snapshot()`.

## Planification d'assertion

Une assertion **plan**-ifiÃ©e assure que les tests passent uniquement quand un certain nombre d'assertions ont Ã©tÃ© exÃ©cutÃ©es. Elle vous aidera Ã  traiter les cas oÃ¹ les tests sortent trop tÃ´t. Elle mettra aussi les tests en Ã©chec si trop d'assertions sont exÃ©cutÃ©es, ce qui peut Ãªtre utile si vous avez des assertions Ã  l'intÃ©rieur des callbacks ou des boucles.

Si vous ne spÃ©cifiez pas une assertion planifiÃ©e, votre test Ã©chouera toujours si aucune assertion n'est exÃ©cutÃ©e. DÃ©finissez l'option `failWithoutAssertions` Ã  `false` dans la [configuration de AVA dans le `package.json`](./06-configuration.md) pour dÃ©sactiver ce comportement.

Il faut savoir que, contrairement Ã  [`tap`](https://www.npmjs.com/package/tap) et [`tape`](https://www.npmjs.com/package/tape), AVA *n'arrÃªte pas* automatiquement un test lorsque le nombre d'assertion prÃ©vu est atteint.

Ces exemples se traduiront par un test rÃ©ussi :

```js
test('se rÃ©sout avec 3', t => {
	t.plan(1);

	return Promise.resolve(3).then(n => {
		t.is(n, 3);
	});
});
```

Ce n'est pas le cas de ces exemples :

```js
test('boucle deux fois', t => {
	t.plan(2);

	for (let i = 0; i < 3; i++) {
		t.true(i < 3);
	}
}); // Echec, 3 assertions de trop sont exÃ©cutÃ©es

test('appelle le callback de maniÃ¨re synchrone', t => {
	t.plan(1);

	someAsyncFunction(() => {
		t.pass();
	});
}); // Echec, le test se termine de faÃ§on synchrone avant que l'assertion soit exÃ©cutÃ©e
```

## Assertions ignorÃ©es

Toute assertion peut Ãªtre ignorÃ©e en utilisant le modificateur `skip`. Les assertions ignorÃ©es sont encore comptÃ©es, donc il n'y a pas besoin de changer le nombre d'assertion dans `plan`.

```js
test('passe une assertion', t => {
	t.plan(2);
	t.is.skip(foo(), 5); // Pas besoin de changer le nombre d'assertion dans `plan`.
	t.is(1, 1);
});
```

## Personnaliser les assertions

Vous pouvez utiliser une bibliothÃ¨que d'assertion qui remplace ou s'ajoute Ã  celui qui est fourni, Ã  condition qu'il renvoie des exceptions lorsque l'assertion Ã©choue.

Cela ne vous donnera pas une aussi bonne expÃ©rience que celle obtenue avec les [assertions intÃ©grÃ©es](#assertions), et vous ne serez pas en mesure d'utiliser la [planification d'assertion](#planification-d-assertion) ([voir #25](https://github.com/avajs/ava/issues/25)).

Vous devrez configurer AVA pour que les tests n'Ã©chouent pas si aucune assertion n'est exÃ©cutÃ©e, car AVA ne peut pas dire si les assertions personnalisÃ©es passent. DÃ©finissez l'option `failWithoutAssertions` Ã  `false` dans la [configuration de AVA dans le `package.json`](./06-configuration.md).

```js
import assert from 'assert';

test('assertion personnalisÃ©e', t => {
	assert(true);
});
```

## Assertions intÃ©grÃ©es

### `.pass(message?)`

L'assertion passe. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.fail(message?)`

L'assertion Ã©choue. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.assert(actual, message?)`

Affirme que `actual` est truthy. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.truthy(actual, message?)`

Affirme que `actual` est truthy. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.falsy(actual, message?)`

Affirme que `actual` est falsy. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.true(actual, message?)`

Affirme que `actual` est Ã  `true`. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.false(actual, message?)`

Affirme que `actual` est Ã  `false`. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.is(actual, expected, message?)`

Affirme que `actual` est le mÃªme que `expected`. Ceci est basÃ© sur [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is). Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.not(actual, expected, message?)`

Affirme que `actual` n'est pas le mÃªme que `expected`. Ceci est basÃ© sur [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is). Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.deepEqual(actual, expected, message?)`

Affirme que `actual` est profondÃ©ment Ã©gale Ã  `expected`. Consulter [Concordance](https://github.com/concordancejs/concordance) pour plus de dÃ©tails.

### `.notDeepEqual(actual, expected, message?)`

Affirme que `actual` n'est pas profondÃ©ment Ã©gale Ã  `expected`. L'inverse de `.deepEqual()`. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.like(actual, selector, message?)`

Affirme que `actual` est comme `selector`. C'est une variante de `.deepEqual()`, cependant `selector` n'a pas besoin d'avoir les mÃªmes propriÃ©tÃ©s Ã©numÃ©rables que `actual`.

Au lieu de cela, AVA dÃ©rive un objet *comparable* de `actual`, basÃ© sur les propriÃ©tÃ©s profondÃ©ment imbriquÃ©es de `selector`. Cet objet est ensuite comparÃ© Ã  `selector` en utilisant `.deepEqual()`.

Toutes les valeurs de `selector` qui ne sont pas des objets courants doivent Ãªtre profondÃ©ment Ã©gales aux valeurs correspondantes de `actual`.

Dans l'exemple suivant, la propriÃ©tÃ© `map` de `actual` doit Ãªtre profondÃ©ment Ã©gale Ã  celle de `selector`. Cependant, `nested.qux` est ignorÃ©, car il n'est pas dans `selector`.

```js
t.like({
	map: new Map([['foo', 'bar']]),
	nested: {
		baz: 'thud',
		qux: 'quux'
	}
}, {
	map: new Map([['foo', 'bar']]),
	nested: {
		baz: 'thud',
	}
})
```

Enfin, il renvoie un boolÃ©en indiquant si l'assertion a rÃ©ussi.

### `.throws(fn, [expectation, [message]])`

Affirme qu'une erreur est levÃ©e. `fn` doit Ãªtre une fonction qui devrait lever une erreur. La valeur levÃ©e *doit* Ãªtre une erreur. Elle est retournÃ©e afin que vous puissiez lancer d'autres assertions. Si l'assertion Ã©choue, alors `undefined` est retournÃ©.

`expectation` peut Ãªtre un objet avec une ou plusieurs des propriÃ©tÃ©s suivantesÂ :

* `instanceOf` : un constructeur, l'erreur levÃ©e doit Ãªtre une "instance de"
* `is` : l'erreur levÃ©e doit Ãªtre strictement Ã©gale Ã  `expectation.is`
* `message` : les types suivants sont valables :
  * une chaÃ®ne - comparÃ©e au message de l'erreur levÃ©e
  * une expression rÃ©guliÃ¨re - qui correspond Ã  ce message
  * une fonction - on lui transmet le message d'erreur et il doit renvoyer un boolÃ©en pour indiquer si l'assertion a passÃ©
* `name` : la valeur `.name` attendue de l'erreur levÃ©e
* `code` : la valeur `.code` attendue de l'erreur levÃ©e

`expectation` n'a pas besoin d'Ãªtre prÃ©cisÃ©. Si vous n'en avez pas besoin mais que vous voulez dÃ©finir un message d'assertion, vous devez spÃ©cifier `undefined`.

ExempleÂ :

```js
const fn = () => {
	throw new TypeError('ðŸ¦„');
};

test('throws', t => {
	const error = t.throws(() => {
		fn();
	}, {instanceOf: TypeError});

	t.is(error.message, 'ðŸ¦„');
});
```

### `.throwsAsync(thrower, expectation?, message?)`

Affirme qu'une erreur est levÃ©e. `thrower` peut Ãªtre une fonction async qui devrait lever une erreur ou une promesse qui devrait Ã©chouÃ©e. Cette affirmation doit Ãªtre attendue (await).

La valeur levÃ©e *doit* Ãªtre une erreur. Elle est renvoyÃ©e afin que vous puissiez exÃ©cuter d'autres assertions. Si l'assertion Ã©choue, alors `undefined` est retournÃ©.

`expectation` peut Ãªtre un objet avec une ou plusieurs des propriÃ©tÃ©s suivantesÂ :

* `instanceOf` : un constructeur, l'erreur levÃ©e doit Ãªtre une "instance de"
* `is` : l'erreur levÃ©e doit Ãªtre strictement Ã©gale Ã  `expectation.is`
* `message` : les types suivants sont valables :
  * une chaÃ®ne - comparÃ©e au message de l'erreur levÃ©e
  * une expression rÃ©guliÃ¨re - qui correspond Ã  ce message
  * une fonction - on lui transmet le message d'erreur et il doit renvoyer un boolÃ©en pour indiquer si l'assertion a passÃ©
* `name` : la valeur `.name` attendue de l'erreur levÃ©e
* `code` : la valeur `.code` attendue de l'erreur levÃ©e

`expectation` n'a pas besoin d'Ãªtre prÃ©cisÃ©. Si vous n'en avez pas besoin mais que vous voulez dÃ©finir un message d'assertion, vous devez spÃ©cifier `undefined`.

Exemple:

```js
test('throws', async t => {
	await t.throwsAsync(async () => {
		throw new TypeError('ðŸ¦„');
	}, {instanceOf: TypeError, message: 'ðŸ¦„'});
});
```

```js
const promise = Promise.reject(new TypeError('ðŸ¦„'));

test('rejects', async t => {
	const error = await t.throwsAsync(promise);
	t.is(error.message, 'ðŸ¦„');
});
```

### `.notThrows(fn, message?)`

Affirme qu'aucune erreur n'est levÃ©e. `fn` doit Ãªtre une fonction qui ne doit pas Ãªtre levÃ©e. Ne renvoie rien.

### `.notThrowsAsync(nonThrower, message?)`

Affirme qu'aucune erreur n'est levÃ©e. `nonThrower` peut Ãªtre une fonction async qui ne devrait pas lever une erreur ou une promesse qui devrait Ãªtre rÃ©solue.

Comme l'assertion `.throwsAsync()`, vous devez attendre que l'assertion se termine :

```js
test('resolves', async t => {
	await t.notThrowsAsync(promise);
});
```

 Ne renvoie rien.

### `.regex(contents, regex, message?)`

Affirme que `contents` correspond Ã  `regex`. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.notRegex(contents, regex, message?)`

Affirme que `contents` ne correspond pas Ã  `regex`. Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.

### `.snapshot(expected, message?)`

Compare la valeur `expected` avec un instantanÃ© enregistrÃ© auparavant. Les instantanÃ©s sont conservÃ©s pour chaque test, donc assurez-vous de donner Ã  vos tests des titres uniques.

### `.try(title?, implementation | macro, ...args?)`

`.try()` vous permet d'*essayer* des assertions sans faire Ã©chouer le test.

La fonction d'implÃ©mentation se comporte de la mÃªme maniÃ¨re que toute autre fonction de test. Vous pouvez mÃªme utiliser des macros. Le premier argument title est toujours facultatif. Les arguments supplÃ©mentaires sont passÃ©s Ã  la fonction d'implÃ©mentation ou Ã  la fonction macro.

`.try()` est une fonction asynchrone. Vous devez indiquer `await`. L'objet rÃ©sultat possÃ¨de les mÃ©thodes `commit()` et `discard()`. Vous devez dÃ©cider si vous voulez valider ou rejeter le rÃ©sultat. Si vous validez un rÃ©sultat qui a Ã©chouÃ©, votre test Ã©chouera.

Vous pouvez vÃ©rifier si la tentative a rÃ©ussi en utilisant la propriÃ©tÃ© `passed`. Les Ã©ventuelles erreurs d'assertion sont disponibles via la propriÃ©tÃ© `errors`. Le titre de la tentative est disponible via la propriÃ©tÃ© `title`.

Les journaux de `t.log()` sont disponibles via la propriÃ©tÃ© `logs`. Vous pouvez choisir de conserver ces journaux dans le cadre de votre test en passant `{retainLogs : true}` aux mÃ©thodes `commit()` et `discard()`.

La fonction d'implÃ©mentation reÃ§oit son propre [contexte d'exÃ©cution](./02-execution-context.md), tout comme une fonction de test. Vous devez faire attention Ã  ne rÃ©aliser des assertions qu'en utilisant le contexte d'exÃ©cution de la tentative. Au moins une assertion doit rÃ©ussir pour que votre tentative rÃ©ussisse.

Vous pouvez exÃ©cuter plusieurs tentatives simultanÃ©ment, dans un seul test. Cependant, vous ne pouvez pas utiliser d'instantanÃ©s lorsque vous le faites.

ExempleÂ :

```js
const twoRandomIntegers = () => {
	const rnd = Math.round(Math.random() * 100);
	const x = rnd % 10;
	const y = Math.floor(rnd / 10);
	return [x, y];
};

test('flaky macro', async t => {
	const firstTry = await t.try((tt, a, b) => {
		tt.is(a, b);
	}, ...twoRandomIntegers());

	if (firstTry.passed) {
		firstTry.commit();
		return;
	}

	firstTry.discard();
	t.log(firstTry.errors);

	const secondTry = await t.try((tt, a, b) => {
		tt.is(a, b);
	}, ...twoRandomIntegers());
	secondTry.commit();
});
```

Renvoie un boolÃ©en indiquant si l'assertion est passÃ©e.
